<?xml version='1.0' encoding='utf-8'?>
<namespace id="pre::json" name="json" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <functiontemplate id="pre::json::from_json" name="from_json">
    <brief> Deserialize any json object or value in a C++ type.</brief>
    <doc>Deserialize any json object or value in a C++ type.

The function throws an std::exception if a mandatory member
isn't found, but doesn't in the case of boost::optional.

The type has to be supported, or adapted with [BOOST\_FUSION\_ADAPT\_STRUCT](http://www.boost.org/doc/libs/release/libs/fusion/doc/html/fusion/adapted/adapt_struct.html).

See below for supported types.

### Example

```cpp
 #include &lt;iostream&gt;
 #include &lt;pre/json/from_json.hpp&gt;

 struct customer {
   std::string name;
   size_t money_spent;
   std::vector&lt;std::string&gt; interests;
 };

 BOOST_FUSION_ADAPT_STRUCT(customer,
   name,
   money_spent,
   interests)

 ...

 std::string string_to_deserialize =
   "{\"interests\":[\"sport articles\"], \"money_spent\":50, \"name\":\"Mrs. Fraulein\"}";

 customer my_customer = pre::json::from_json&lt;customer&gt;(string_to_deserialize);

 std::cout &lt;&lt; "Customer " &lt;&lt; my_customer.name &lt;&lt; " spent " &lt;&lt;
   my_customer.money_spent &lt;&lt; std::endl;

```

  - [Full example](examples/from_json.cpp)
  - [Extended examples](test/dejsonize_test.cpp)

### Supported types

  - [Any Integral Types](http://en.cppreference.com/w/cpp/types/is_integral)
  - [std::basic_string, std::string...](http://en.cppreference.com/w/cpp/string/basic_string)
  - [Aggregate/struct adapted with Boost.Fusion](http://www.boost.org/doc/libs/master/libs/fusion/doc/html/fusion/adapted/adapt_struct.html)
  - [Any Container](http://en.cppreference.com/w/cpp/concept/AssociativeContainer) ( i.e. std::vector, std::list...)
  - [Any AssociativeContainer](http://en.cppreference.com/w/cpp/concept/AssociativeContainer) ( i.e. std::map, std::set, std::multimap...)
  - [boost::optional&amp;lt;X&amp;gt;](http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html)
  - [boost::variant&amp;lt;Xs...&amp;gt;](http://www.boost.org/doc/libs/release/doc/html/variant.html)
  - [boost::chrono::duration](http://www.boost.org/doc/libs/release/doc/html/chrono.html)
  - [std::chrono::duration](http://en.cppreference.com/w/cpp/chrono/duration)

</doc>
    <return>
      <doc>the type wanted if it succeed find all member and value in the json.</doc>
      <type name="T" />
    </return>
    <argument id="pre::json::from_json::serialized_json" name="serialized_json">
      <doc>json to deserialize</doc>
      <type name="std::string" qualifier=" const &amp;" />
    </argument>
    <templatetypeparameter id="pre::json::from_json::T" name="T">
      <brief>The result type wanted from the deserialization. that will be filled from the given json_object.</brief>
    </templatetypeparameter>
  </functiontemplate>
  <functiontemplate id="pre::json::from_json" name="from_json">
    <brief> Same as pre::json::from_json(const std::string&amp;) but directly with a JSON.</brief>
    <return>
      <type name="T" />
    </return>
    <argument id="pre::json::from_json::json_object" name="json_object">
      <type name="nlohmann::json" qualifier=" const &amp;" />
    </argument>
    <templatetypeparameter id="pre::json::from_json::T" name="T" />
  </functiontemplate>
  <functiontemplate id="pre::json::to_json" name="to_json">
    <brief> Serialize to a JSON object any C++ object of any type, even your own types. </brief>
    <doc>Serialize to a JSON object any C++ object of any type, even your own types.

It uses type traits introspection as well as Boost.Fusion reflection information to generate JSON from any types.

### Example

```cpp
  #include &lt;iostream&gt;
  #include &lt;pre/json/to_json.hpp&gt;

  struct customer {
    std::string name;
    size_t money_spent;
    std::vector&lt;std::string&gt; interests;
  };

  BOOST_FUSION_ADAPT_STRUCT(customer,
    name,
    money_spent,
    interests)

 ...

 customer my_customer{
   "Mr. Dupond",
   1000,
   {"sport articles", "food", "tools"}
 };

 std::cout &lt;&lt; pre::json::to_json(my_customer) &lt;&lt; std::endl;
```

  - [Full example](examples/to_json.cpp)
  - [Extended examples](test/dejsonize_test.cpp)

### Supported types

  - [Any Integral Types](http://en.cppreference.com/w/cpp/types/is_integral)
  - [std::basic_string, std::string...](http://en.cppreference.com/w/cpp/string/basic_string)
  - [Aggregate/struct adapted with Boost.Fusion](http://www.boost.org/doc/libs/master/libs/fusion/doc/html/fusion/adapted/adapt_struct.html)
  - [Any Container](http://en.cppreference.com/w/cpp/concept/AssociativeContainer) ( i.e. std::vector, std::list...)
  - [Any AssociativeContainer](http://en.cppreference.com/w/cpp/concept/AssociativeContainer) ( i.e. std::map, std::set, std::multimap...)
  - [boost::optional&amp;lt;X&amp;gt;](http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html)
  - [boost::variant&amp;lt;Xs...&amp;gt;](http://www.boost.org/doc/libs/release/doc/html/variant.html)
  - [boost::chrono::duration](http://www.boost.org/doc/libs/release/doc/html/chrono.html)
  - [std::chrono::duration](http://en.cppreference.com/w/cpp/chrono/duration)


</doc>
    <return>
      <doc>An [nlohmann::json](https://github.com/nlohmann/json/) object directly streamable to std::cout or convertible to string.</doc>
      <type name="nlohmann::json" />
    </return>
    <argument id="pre::json::to_json::value" name="value">
      <doc>A value adapted with [BOOST\_FUSION\_ADAPT\_STRUCT](http://www.boost.org/doc/libs/release/libs/fusion/doc/html/fusion/adapted/adapt_struct.html).
       This value can be any aggregate with nested aggregate or any C++ types.</doc>
      <type name="const T" qualifier=" const &amp;" />
    </argument>
    <templatetypeparameter id="pre::json::to_json::T" name="T">
      <brief>Any of the Supported Types.</brief>
    </templatetypeparameter>
  </functiontemplate>
</namespace>
